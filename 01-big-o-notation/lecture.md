# Big O notation

ในบทนี้เราจะมาพูดถึงเรื่อง Big O notation คร่าวๆเจ้าตัวนี้เนี่ยจะถูกใช้ในการวัดอัตราการเติบโตของข้อมูลโดยเราจะนำมันมาใช้ในการวัดว่า algorithm ของเราเนี่ยอันไหนเหมาะในการใช้งานมากกว่ากัน

## Problem and Solution

ก่อนที่เราจะเริ่มเกริ่นถึงเรื่อง Big O notation เราจะมาพูดถึงเรื่องปัญหาและวิธีแก้ไขปัญหากันก่อน
เรื่องนี้ค่อนข้างสำคัญมากเลยทีเดียว เพราะมันจะไม่ make sense เลยถ้าเราจะมัวแต่หา solution โดยที่ไม่ทำความเข้าใจปัญหาเสียก่อน เพราะปัญหาหนึ่งปัญหาเนี่ยมันมีได้หลาย solutions เลยแต่อันไหนดีสุดเนี่ยมันก็ขึ้นอยู่กับบริบท (context) ของปัญหาล้วนๆไม่มีเครื่องมือหรือวิธีแก้ปัญหาใดๆที่ดีที่สุดหรือแก้ได้ทุกอย่างในโลกใบนี้ การที่เรามองว่าเครื่องมือหรือวิธีแก้ปัญหาใดๆสามารถแก้ได้ทุกปัญหาเนี่ยเราเรียกกันว่า Sliver bullet ซึ่งในชีวิตจริงมันไม่ใช่แบบนั้น ค้อนไม่สามารถแก้ได้ทุกปัญหา
ทุกเครื่องมือถูกสร้างมาโดยที่มี principle ของมันหรือเหตุผลของมันเอง

ปัญหาเนี่ยผมมองว่ามันคือ gap ระหว่างสิ่งที่เป็นอยู่กับสิ่งที่เราคาดหวังให้มันเป็นหรือ gap ของ A ไป B สิ่งที่เป็นอยู่เราเรียกมันว่า Actual State ส่วนสิ่งที่เราคาดหวังให้มันเป็นเราเรียกว่า Desired State

![image](https://learnalgorithm.com/_image?href=%2F_astro%2Fwhat-is-problem__definition-context.D_j3tsV5.png&f=webp)
_รูปภาพจาพจากเว็บไซต์ learnalgorithm.com_

ซึ่งการแก้ไขปัญหาเนี่ยคือเส้นที่จะ transform เราจาก A ไป B หรือเขียนได้เป็น A -> B และแน่นอนว่าเส้นที่ transform เราจาก A -> B มีได้มากกว่า 1 เส้นโดยที่เส้นที่ transform เราจาก A ไป B มันคือ step ขั้นตอนที่จะพาเราจาก A ไป B ที่ผมเรียกว่ามันคือ step เนี่ยเพราะว่าถ้าเราบอกว่ามันคือการ transform เฉยๆมันจะคลุมเครือเพราะว่าถ้าสมมุติผมบอกว่า "ผมจะไปเชียงใหม่จากกรุงเทพยังไง" ถ้าเราตอบแค่ว่าก็เดินทางด้วยอะไรสักอย่างไปไง ไปด้วยรถไฟสิ ขับรถไปดิ นั่งเครื่องบินไปสิ การตอบแบบนี้มันก็ไม่ผิดแต่มันไม่ได้อธิบายว่ายังไงด้วยน่ะสิ ถ้ายังไม่เห็นภาพถ้าผมบอกอยากทำข้าวผัด แล้วผมตอบว่า วิธีทำข้าวผัดก็คือ เอาข้าวลงไปผัด เราจะรับกับคำตอบแบบนี้ได้หรือเปล่าก็คงอาจจะไม่เราอยากรู้ step และวิธีด้วยเช่น ไปหยิบกระทะก่อน -> วางบนเตาแก๊ส -> จุดแก๊ส -> เทน้ำมัน -> รอน้ำมันเดือด -> หยิบไข่ -> ตอกไข่ลงไป .... ถ้าเป็นคำตอบแบบนี้จะชัดเจนมากกว่าแน่นอนว่าการตอบสั้นๆนั้นก็ไม่ผิดแต่มันคลุมเครือและไม่ชัดเจนเฉยๆ ในเมื่อมันมีหลากหลายวิธี/solution แล้วละก็เราจะรู้ได้ไงว่าแบบไหนดีหรือไม่ดีแบบไหนเหมาะหรือไม่เหมาะ วิธีการก็คือการตีกรอบของปัญหานั่นเองครับ

### Problem Context

ก็คือการกำหนดขอบเขตหรือบริบทของปัญหาจากตัวอย่างเมื่อกี้ที่ว่า "ผมจะไปเชียงใหม่จากกรุงเทพยังไง" โอ้วมีทั้งเครื่องบิน รถไฟ ไปแบบไหนดีล่ะแน่นอนว่าทั้งสองวิธีพาเราไปเชียงใหม่ได้ทั้งคู่ แต่การที่จะเลือกผมอาจจะตีกรอบมาว่าอยากจะ ปรับหยัดตัง ไม่ต้องตื่นเช้ามาก และไม่รีบ จากบริบทตรงนี้นั่งรถไฟอาจจะดีกว่า แต่ถ้าผมมบอกว่าเอ่อผมไม่สนเรื่องราคาหรอกแต่ผมจะต้องรีบไปอ่ะ ตัวเลือกนี้จะเปลี่ยนเป็นเครื่องบินทันทีเพราะใช้เวลาแค่ชั่วโมงนิดๆ การตีกรอบของปัญหาหรือการกำหนัดบริบททำให้เราสามารถตัดวิธีอื่นๆออกไปได้และคงเหลือไว้แค่ solution ที่เหมาะสมกับปัญหา/บริบทของเรา หรือว่าจะเป็นที่โลกปัจจุบันนี้หลายๆประเทศแข่งกันผลิตชิปการ์ดจอเพื่อประมวลผลการย่อยขนาดการผลิตชิปเพื่อเพิ่มจำนวน transistor แต่เมื่อถึงจุดๆนึงเราจะพบว่าเมื่อพัฒนาไปเรื่อยๆเราอาจจะพบกับปัญหาใหม่ๆเช่น เมื่อ transistor เล็กลงเรื่อยๆเราจะพบกับพฤติกรรมที่เรียกว่า Quantum Tunneling หรือการที่ electron จะทะลุจาก transistor นึงไปยังอีกตัวนึง ส่วนวิธีแก้ก็มีหลายวิธี เช่นการผลิต transistor ชนิดใหม่ๆหรือแม้กระทั้งการเปลี่ยนจาก classical computer ไป quantum computer

โอเคผมเกริ่นนอกเรื่องไปค่อนข้างเยอะและเรากลับเข้าสู่หัวข้อของ Big O notation กันดีกว่าในการวัดประสิทธิภาพของ algorithm ที่เราจะใช้ในการเขียนโปรแกม เนี่ยเราจะคำนึงถึง 2 cost หลักๆครับก็คือ ระยะเวลาในการรัน (time) และขนาดพื้นที่ ที่จะต้องใช้ (memory space) เราเรียก cost นี้ว่า Computation Complexity โดยเราจะ evaluate มันด้วย Big O

## Big O

ตามที่ผมเข้าใจ Big O มันคือการวัดอัตราการเติบโตก็คือการวัดว่าถ้าเรามี input ขนาด n เนีย algorithm ของเราจะมีอัตราการเติบโตของ n "ที่แย่ที่สุด" เป็นเท่าไหร่ (worst-case complexity)
ตัวอย่างเช่นนะ ผมต้องการหาข้อมูลใน array ที่มีขนาด n ตัวสมมุติว่า n = 100 และถ้าผมต้องการหาตัวเลข 14 ใน array นี้โดยค้นหาทีละตัวจากตัวแรกจนตัวท้าย worst case ดังนั้นกรณีที่แย่ที่สุดของผมคือต้องหา n ครั้งใช่ไหมล่ะครับคือเราไม่สนหรอกนะว่ามันจะมีกรณีที่ 14 อาจจะอยู่ตัวแรกก็ได้แต่คือ Big O มันวัดกรณีที่แย่ที่สุดไงเพราะฉะนั้นเราไม่สนหรอกว่าจะโชคดีไหมแต่อยากรู้ว่าแย่สุดๆอ่ะจะต้องใช้เวลาเท่าไหร่ในการหาอย่างกรณีนี้เราสรุปได้ว่า Big O ของผมคือ O(n) ก็คือขนาดจะมีค่าเท่ากับ n

มาดูอีกอันดีกว่า function ยกกำลัง 2

```python
def square(x: int) -> int:
   return x**2
```

ฟังชั่นนี้ไม่ว่า x (n) จะเป็นเท่าไหร่ระยะเวลาหรืออัตราการเติบของ n เราจะเท่ากับ 1 เสมอไม่ว่า n จะ 100, 1000, 10000 เราก็จะทำแค่ครั้งเดียวแบบนี้เราเรียกว่า constant หรือ O(1)

อีกตัวอย่างละกันก็คือการลบตัวเลขซ้ำใน array แล้ว return array ที่ลบตัวซ้ำออกไปแล้ว

```python
def remove_duplicate(array: list[int]) -> list[int]:
    result = []
    # O(n**2)
    for i in range(len(array)):
        found = False
        # O(n)
        for j in range(len(result)):
            if result[j] == array[i]:
                found = True
                break
        if not found:
            result.append(array[i])
    return result
```

โค้ดด้านบนเราทำการวนตัวเลขออกมาจาก array และทำการเก็บตัวเลขไว้ใน result array ถ้าเกิดว่าตัวเลขไหนมีแล้วใน result เราะจะไม่เพิ่มลงไปใน result array ส่วน Big O ของฟังชั่นหรือ algorithm นี้คือ O(n^2) อ่าวทำไมถึงเป็น O(n^2) ล่ะทำไมไม่ใช่ O(n^2 + n) คำตอบก็คือการ evaluate algorithm มันคือการวัด cost คร่าวๆเท่านั้นเป็นการประมาณนั่นแหละเพราะฉะนั้นมันจะสนใจแค่ dominant term เท่านั้นหรือพูดง่ายๆว่าสนใจแค่ Big O ที่มีอัตราการเติบโตมากที่สุดใน algorithm เท่านั้น
ไม่ว่า cost(n) = 4n + n^2 เราก็จะตัดหรือแค่ dominant term เหลือแค่ว่า cost(n) ≈ n^2

ด้านล่างนี้คือตารางของ Big O แบบต่างๆ

| **Big-O**       | **ชื่อ**          | **คำอธิบาย**                                                     | **ตัวอย่าง**                                                         |
| --------------- | ----------------- | ---------------------------------------------------------------- | -------------------------------------------------------------------- |
| \(O(1)\)        | Constant Time     | ใช้เวลาเท่ากันเสมอ ไม่ว่าข้อมูลจะใหญ่แค่ไหน                      | การเข้าถึง element ใน array โดยใช้ index, การคำนวณค่าสมการง่ายๆ      |
| \(O(\log n)\)   | Logarithmic Time  | เวลาที่ใช้เพิ่มขึ้นตามขนาดข้อมูล log n                           | Binary Search, การ traversal ใน Balanced Binary Search Tree          |
| \(O(n)\)        | Linear Time       | เวลาที่ใช้เพิ่มขึ้นตามขนาดของข้อมูล                              | การ traverse array/list, การหาเลขมากที่สุดใน array                   |
| \(O(n \log n)\) | Linearithmic Time | การทำงานที่เร็วกว่า Quadratic นิดหน่อย แต่ช้ากว่า Linear         | Merge Sort, Quick Sort, การจัดกลุ่มข้อมูลในลำดับเฉพาะ                |
| \(O(n^2)\)      | Quadratic Time    | เวลาที่ใช้เพิ่มขึ้นเยอะมากตามขนาดของข้อมูล (มี nested loop)      | Bubble Sort, Selection Sort, Insertion Sort (แบบที่ไม่ได้ optimized) |
| \(O(n^3)\)      | Cubic Time        | เวลาที่ใช้เพิ่มขึ้นเยอะกว่า Quadratic เพราะมี nested loop 3 ชั้น | การคำนวณ matrix multiplication แบบ naive                             |
| \(O(2^n)\)      | Exponential Time  | เวลาเพิ่มขึ้นแบบกำลัง 2 (ใช้สำหรับปัญหาที่แก้ด้วย brute force)   | การแก้ปัญหา Traveling Salesman, Subset Sum (Brute Force)             |
| \(O(n!)\)       | Factorial Time    | เวลาเพิ่มขึ้นแบบ Factorial (ปัญหาที่ต้อง generate permutations)  | การสร้าง permutation ของตัวเลข \(n\) ตัว                             |
